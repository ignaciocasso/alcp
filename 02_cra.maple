

######### COMPROBAR QUE FUNCIONAN EN MAPLE Y EXTENDER A OTROS DOMINIOS EUCLIDEOS


######################## Normal #####################

#Algoritmo para calcular el inverso del teorema chino de los restos para los enteros
#Para generalizarlo a qualquier dominio, suponiendo eea ya generalizado, basta con sustituir
# *,/,mod,+ por los del dominio euclideo, y redefinir product y sum para que funciones con las
#nuevas versiones de + y *.
#Se usa / porque se sabe que la division es exacta, quotient() tambien valdria (es facil ver que en este
#caso quotient es unico en cualquier dominio euclideo).
#El algoritmo funciona perfectamente aunque eea o remainder() no tengan solucion unica, lo unico que
#la solucion del algoritmo tampoco lo sera. Si se quiere solucion unica, hace falta un remainder unico
#y consistente (mod en nuestro caso).


inverso := proc (m, v)
  local k, s;
  local prod = product(m[i], i = 1 .. nops(m));
  for i to nops(m) do
    k[i] := prod/m[i];
    _, s, _ := eea(k[i],m[i]);
    c[i] := v[i]*s mod m[i];
  end do;
  local ret := sum(c[i]*k[i], i = 1 .. nops(m));
  RETURN(ret mod prod);
end proc;


####################### GARNER #############################

#algoritmo de garner para calcular el inverso del teorema chino de los restos para los enteros
#para generalizarlo a cualquier dominio euclideo, habria que generalizar eea, y sustituir 
#+,-/2,* y mod por los del dominio euclideo (mod=rem)

inverso_mod := proc(k,m)
  local g,s,t = eea(k,m); #g=1, si no no hay inverso
  RETURN(s);
end proc;


garner := proc(m,v)
  local inv := 0;
  local pm := 1;
  for i from 1 to nops(m) do
    u[i]:=(v[i]-inv)*inverso_mod(pm,m[i]) mod m[i];
    inv := u + u[i]*pm;
    pm := pm*m[i];
  end do;
  RETURN(inv mod pm);
end proc;