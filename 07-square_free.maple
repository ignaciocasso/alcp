#algoritmo de yun para square free factorization

# La factorizacion libre de cuadrados de f en Fq[x] es (g1,...,gm), con f = prod gi^i, gm!=0, mcd(gi,gj)=1

# Base matematica del algoritmo:
# mcd(f,f') = prod gi^(i-1)
# w = f/c = prod gi
# y = f'/c = prod (i*gi'*prod(gj))       (j!=i)
# z = y - w' = prod((i.1)*gi'*prod(gj)) = g1*(...) (j!=i)
# mcd(w,z) = g1, y si f2=c=f/w entonces w2=w/g1 y y2=z/g1
# Se puede comprobar todo esto, pero es un co√±azo

# f' podria ser 0 en un cuerpo de caracteristica 0, asi que hay que separar ese caso
# Por suerte, la unica forma de que eso pase es que todos los coeficientes de exponentes
# no multiplos de p sean nulos, asi que es facil de tratar (f = h^p para un polinomio h facil de calcular)


square_free := proc(f,p,k,x) #square_free factorization de f un polinomio de Fq[x], q=p^k
  local q := p^k;
  local n := degree(f,n);
  df := Diff(f,x) mod p;
  if df=0 then     #expand antes?  # necesariamente f = sum a_pi*x^pi = h^p, con h=sum a_pi*x^i
    f2 := sum(coeff(f,x,p*i)*x^i, i=0..iquo(n,p));  #comprobar si se puede sustituir por /
    sqf := square_free(f2,p,k,x);
    for i from 1 to iquo(n,p) do
      ret[p*i] := sqf[i];  #Seran las demas 0? 
    end do;
    return ret;
  end if;
  i:=1;
  c := Gcd(f,df) mod p;
  w := f/c;	 #funciona? Quo() si no
  y := df/c;
  z := Diff(w,x) mod p;
  z := y-z;
  while z<>0 do
    ret[i] := Gcd(w,z) mod p;
    w := w/ret[i];
    y := z/ret[i];
    z := Diff(w,x) mod p;
    z := y - z;
    i := i+1;
  end do;
  return ret;
end proc;