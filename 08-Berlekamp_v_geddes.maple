
############ Parece que funciona

# f es un polinomio square-free en Fq[x] de grado n, y factoriza en f1,...,fr

# Denotamos K = Fq[x]/<f>, Ki = Fq[x]/<fi>, y sabemos que K es isomorfo a K1 x ... x Kr, vía el isomorfismo h

# K es un espacio vectorial n-dimensional sobre Fq, con base {1,x,...,x^n-1}

# Nos interesa el conjunto W = { v pertenecientes a K | v^q = v }, que es subespacio vectorial de K (fácil de comprobar)

# Si f es irreducible => K es un cuerpo => z^q - z tiene exactamente q raíces en K => el conjunto de esas raíces es Fq => W es Fq y tiene dimensión 1

# Si restringimos h a W, nos queda un isomorfismo hw entre W y W1 x...x Wr (fácil de comprobar)

# De las dos afirmaciones anteriores se deduce que W tiene dimensión r

# Sea v(x) en W. x^q-x = prod(x-s | s en Fq) => v^q-v = prod(v-s | s en Fq). Por otro lado, mcd(v-s1,v-s2)=1, y fi | f | v^q-v
# De esto se deduce que fi divide a exactamente un v-s, y que f = prod( mcd(v-s,f) | s en Fq)

# Además si tenemos {v1,...,vr} una base de W, como hw es isomorfismo y W1 x...x Wr = Fq x...x Fq, tenemos que
# para todo i,j, existe k,, a = hwi(vk) != hwj(vk) = b => fi | vk-a, fj | vk-b

# Por lo tanto, si obtenemos una base de W, mediante mcds entre v-s y f o otros factores ya calculados de f, podemos acabar separando f en todos sus factores
# irreducible, y en eso se basa el algoritmo de Berlekamp

# Necesitamos entonces obtener una base de W, y lo haremos a partir de la matriz Q del homomorfismo de K -> K, g -> g^q - g, cuyo núcleo es W.

berlekamp := proc(f,x,p,k,alpha)
    local Q,B,n,mcd,factors,factor,v,fqelem,r;
    Q := construirQ(f,x,p,p^k);
    B := Nullspace(Q) mod p;
    factors := {f};
    n := degree(f,x);
    for r from 2 to numelems(B) do  # B[1] va a ser siempre 1;
        v := seq(B[r][i], i=1..n);
        v := sum(v[i] * x^(i-1), i=1..n);
        for factor in factors do
            for fqelem in fq(p,k,alpha) do
                mcd := Gcd(v-fqelem,factor) mod p;
                if mcd<>1 and mcd<>factor then
                    factors := factors minus {factor};
                    factor := Quo(factor,mcd,x) mod p;
                    factors := factors union {factor,mcd};
                    if numelems(factors)=numelems(B) then
                        return factors;
                    end;
                end;
            end do;
        end do;
    end do;
end proc;

fq := proc(p,k,alpha)
    return seq(fun(m,p,k,alpha), m=0..p^k-1);
end proc;

fun := proc(n,p,k,alpha)
    local ret := 0;
    local i;
    local m := n;
    for i from 1 to k do
        ret := ret + irem(m,p)*w^(i-1);
        m := iquo(m,p);
    end do;
    return ret;
end proc;
    
construirQ := proc(f,x,p,q)
    local n,k,fun;
    n := degree(f,x);
    g||1 := 0; # imagen de 1
    for k from 1 to n-1 do
        g||(k+1) := Powmod(x,q*k,f,x) mod p - x^k mod p; # imagen de x^k;
    end do;
    fun := (i,j) -> coeff(g||j,x,i-1); # La columna i-iésima de Q es la imagen de Bi = x^(i-1)
    return Matrix(n,fun);
end proc;

# Optimizaiones
    # Si f(x) = a0 +...+ an*x^n, entonces x^n mod f es -a0 -...- an-1*x^(n-1)
    # Si x^m mod f = b0 +...+bn-1*xn-1 => x^(m+1) mod f = bo*x + ... + bn-1*x^n = bo*x +...+bn-1*(-a0-...-an-1*xn-1) = -bn-1*a0 + (b0-bn-1*a1)x + ...,
    # y se pueden sacar iterativamente los x^qi mod f